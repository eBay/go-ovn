package goovn

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

// For this test we don't need all these fields
// This type can be autogenerated
type testLS struct {
	UUID             string            `ovs:"_uuid"`
	QosRules         []string          `ovs:"qos_rules"`
	OtherConfig      map[string]string `ovs:"other_config"`
	ExternalIds      map[string]string `ovs:"external_ids"`
	ForwardingGroups []string          `ovs:"forwarding_groups"`
	Name             string            `ovs:"name"`
	Ports            []string          `ovs:"ports"`
	Acls             []string          `ovs:"acls"`
	LoadBalancer     []string          `ovs:"load_balancer"`
	DnsRecords       []string          `ovs:"dns_records"`
}

func (*testLS) Table() TableName { return "Logical_Switch" }

// For this test we don't need all these fields
// This type can be autogenerated
type testLSP struct {
	UUID             string            `ovs:"_uuid"`
	Type             string            `ovs:"type"`
	TagRequest       []int             `ovs:"tag_request"`
	Tag              []int             `ovs:"tag"`
	DynamicAddresses []string          `ovs:"dynamic_addresses"`
	PortSecurity     []string          `ovs:"port_security"`
	Enabled          []bool            `ovs:"enabled"`
	Name             string            `ovs:"name"`
	Up               []bool            `ovs:"up"`
	Dhcpv4Options    []string          `ovs:"dhcpv4_options"`
	HaChassisGroup   []string          `ovs:"ha_chassis_group"`
	ExternalIds      map[string]string `ovs:"external_ids"`
	Dhcpv6Options    []string          `ovs:"dhcpv6_options"`
	Options          map[string]string `ovs:"options"`
	ParentName       []string          `ovs:"parent_name"`
	Addresses        []string          `ovs:"addresses"`
}

func (*testLSP) Table() TableName { return "Logical_Switch_Port" }

// This simple test just adds a Logical Switch and a Logical Port associated with it
// More than a Unit Test, it's a demonstrator
func TestORMUpdate(t *testing.T) {
	DBmodel, err := NewDBModel([]Model{&testLS{}, &testLSP{}})
	if err != nil {
		t.Fatal(err)
	}
	orm := getOVNClientORM(DBNB, DBmodel)

	// Add a Logical Switch
	ls1 := testLS{
		Name:        "someswitch",
		ExternalIds: map[string]string{"foo": "bar"},
	}
	createLSOp, err := orm.Create(&ls1)
	assert.Nil(t, err)

	err = orm.Execute(createLSOp)
	assert.Nil(t, err)

	// Reread ls1 to get UUID. TODO: have Execute (or even Create()) return the created UUID?
	err = orm.Get(&ls1, "name")
	assert.Nil(t, err)

	// Add a Logical Switch Port
	uuid, err := newRowUUID()
	assert.Nil(t, err)
	lsp1 := testLSP{
		UUID: uuid,
		Name: "someport",
	}
	createLSPOp, err := orm.Create(&lsp1)
	assert.Nil(t, err)

	// Update LSP to point to LSP
	ls1.Ports = append(ls1.Ports, lsp1.UUID)
	updateOp, err := orm.Update(&ls1)
	assert.Nil(t, err)

	err = orm.Execute(createLSPOp, updateOp)
	assert.Nil(t, err)

	// Verify:
	var switches []testLS
	var sports []testLSP
	err = orm.List(&switches)
	err = orm.List(&sports)
	assert.Len(t, switches, 1)
	assert.Len(t, sports, 1)
	assert.Equal(t, switches[0].Ports[0], sports[0].UUID)

	// Delete by Update
	ls1.Ports = []string{}
	updateOp2, err := orm.UpdateFields(&ls1, []string{"ports"})
	assert.Nil(t, err)

	err = orm.Execute(updateOp2)
	assert.Nil(t, err)
	// Verify the port has been deleted from the DB
	err = orm.Get(&lsp1)
	if err != ErrorNotFound {
		t.Errorf("Port was not deleted after removing its only reference")
	}

	// Delete
	deleteOp, err := orm.Delete(&ls1)
	assert.Nil(t, err)
	err = orm.Execute(deleteOp)
	assert.Nil(t, err)

	var switches2 []testLS
	err = orm.List(&switches2)
	assert.Len(t, switches2, 0)
}
